##Oracle 12c+ only
create table t1 (
    c1 NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1),
    c2 VARCHAR2(10)
    );

Next we need to add a PRIMARY KEY constraint:

ALTER TABLE books
  ADD (
    CONSTRAINT books_pk PRIMARY KEY (id)
  );

##without auto increment
CREATE TABLE books (
  id      NUMBER(10)    NOT NULL,
  title   VARCHAR2(100) NOT NULL
);
Next we need to add a PRIMARY KEY constraint:

ALTER TABLE books
  ADD (
    CONSTRAINT books_pk PRIMARY KEY (id)
  );
Finally, weâ€™ll create our SEQUENCE that will be utilized later to actually generate the unique, auto incremented value.

CREATE SEQUENCE books_sequence;



-----------------------------------------------------------

TIMEZONE IN ORACLE

-----------------------------------------------------------
select dbtimezone, sessiontimezone from dual


select TO_CHAR(from_tz(timestamp '2021-11-11 08:00:00','+2:00') at time zone 'Asia/Jerusalem','MM-DD-YYYY HH:MI:SS') from dual


--created field is unix epoch like this 1635831754978
select to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(created/1000,'SECOND'),(select dbtimezone from dual)) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS') from spt_table where name='input_name'

--created field is unix epoch like this 1635831754978
select to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(created/1000,'SECOND'),('+2:00')) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS') from spt_table where name='input_name'



---1635831754978 == 02-11-2021 07:42
select TO_TIMESTAMP('1970-01-01','YYYY-MM-DD')+NUMTODSINTERVAL(1635831754978/1000,'SECOND') from dual
select TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(1635831754978/1000,'SECOND'),'0:00') at time zone 'Asia/Jerusalem','MM-DD-YYYY HH:MI:SS') from dual

select bundle_created_date,bundle_modified_date, trunc (minutes_ /60) || ' Hours, ' || trunc(mod(minutes_,60)) || ' minutes ' diff
from ( 

select 
 to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(created/1000,'SECOND'),(select dbtimezone from dual)) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS') bundle_created_date,
to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(modified/1000,'SECOND'),(select dbtimezone from dual)) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS') bundle_modified_date,
(to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(modified/1000,'SECOND'),(select dbtimezone from dual)) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS') 
- to_date(TO_CHAR(from_tz(TO_TIMESTAMP('1970-01-01','YYYY-MM-DD HH24:MI:SS')+NUMTODSINTERVAL(created/1000,'SECOND'),(select dbtimezone from dual)) at time zone 'Asia/Jerusalem','MM-DD-YYYY HH24:MI:SS'),'MM-DD-YYYY HH24:MI:SS')) *24*60 as minutes_
from spt_bundle


)



--following statement shows id_number that DOES NOT EXIST!!!! table
drop type string_tab force;
create type string_tab is table of varchar(9);
SELECT *   FROM TABLE(string_tab('id','id1','id2'))
WHERE COLUMN_VALUE NOT IN (SELECT id_number FROM table);
--release_variable string_tab
drop type string_tab force;


-count all rows
select count(*) from table_name

--count doubled rows
select count(*) from table_name where rowid not in (select min(rowid)   from table_name group by list_of_fields)

--delete doubled rows
delete from table_name where rowid not in (select min(rowid) from table_name group by list_of_fields)



+-----------------------------------------------------------+
|															|
|		IF FIRST QUERY RETURN EMPTY USE ANOTHER				|
|															|
+-----------------------------------------------------------+
source (https://stackoverflow.com/questions/12980854/oracle-db-return-second-query-if-first-query-is-empty)
WITH query1 as (
    select 1, 2
    from dual
    where 1=0
    connect by level <= 10
),
query2 as (
    select 3, 4
    from dual
    connect by level <= 10
)
select *
from query1
union all
select *
from query2
where not exists (
    select null
    from query1
);

<<<<<<< HEAD


+-----------------------------------------------------------+
|															|
|		child column is csv									|
|															|
+-----------------------------------------------------------+
https://medium.com/swlh/three-routes-convert-comma-separated-column-to-rows-c17c85079ecf
=======
+-----------------------------------------------------------+
|															|
|	Three Routes: Convert Comma-Separated Column to Rows	|
|															|
+-----------------------------------------------------------+
//https://medium.com/swlh/three-routes-convert-comma-separated-column-to-rows-c17c85079ecf
column a is parent column b is csv of children (parent_and_csv_of_children)

>>>>>>> eb6c2559bcad0fd16c7606d67b9db8117543d3cf
select t.customer,
trim(regexp_substr(t.orders, '[^,]+', 1, lines.column_value))
as "Order"
from checkout t,
table(cast(multiset(
select level from dual
connect by level <=
regexp_count(t.orders, ',')+1
) as sys.odciNumberList
)
)lines
order by customer,
lines.column_value;

+-----------------------------------------------------------+
|															|
|	check only digits										|
|															|
+-----------------------------------------------------------+
https://stackoverflow.com/questions/3932230/oracle-sql-query-that-returns-rows-with-only-numeric-values
SELECT X  FROM SO WHERE REGEXP_LIKE(X, '^[[:digit:]]+$');